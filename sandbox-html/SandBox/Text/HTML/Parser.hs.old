{-# LANGUAGE FlexibleContexts #-}

module SandBox.Text.HTML.Parser (
    parseHTML
  , parseTag
  , html
, doctype
, cdata
, comment
, startTag
, charRef
, attrValue
, attribute
, attributes
, decimalCharRef
, hexadecimalCharRef
, namedCharRef
, test1
, test2
, test3
, test4
, test5
, lookAheadSuccess
  ) where

import Control.Monad.Identity (Identity)
import Data.Char (chr, toLower)
import Numeric (readHex)
import Text.Parsec (
      (<|>), (<?>), Stream, ParsecT, ParseError, alphaNum, anyChar, between, char, digit,
      hexDigit, letter, lookAhead, many, many1, manyTill, oneOf,
      option, optionMaybe, optional, parse, satisfy, sepBy1, skipMany, skipMany1,
      string, try, unexpected
    )

import SandBox.Text.HTML.Char (
      isAllowedRefChar, isAttrNameChar, isSpaceChar, isTextChar
    , isDoubleQuotedAttrValueChar
    , isSingleQuotedAttrValueChar
    , isUnquotedAttrValueChar
    )
import SandBox.Text.HTML.Types (HTML(..), DOCTYPE(..), DTDKind(..), Tag(..), Attribute(..))
import SandBox.Text.HTML.NamedCharRef (charRefNameToMaybeString)

parseHTML :: Stream String Identity Char =>
    String -> Either ParseError HTML
parseHTML = parse html ""

html :: Stream s m Char => ParsecT s u m HTML
html = do
    -- TODO: optional byte order mark
    commentOrSpaces
    d <- doctype
    commentOrSpaces
    root <- startTag
    commentOrSpaces
    return $ HTML d root


doctype :: Stream s m Char => ParsecT s u m DOCTYPE
doctype =
    between 
        (caseInsensitiveString "<!DOCTYPE" >> spaces1 >>
         caseInsensitiveString "html")
        (spaces >> char '>')
        (doctypeSystemSub
         <|> doctypePublicSub
         <|> return (DOCTYPE "html" Nothing Nothing Nothing))

doctypeSystemSub :: Stream s m Char => ParsecT s u m DOCTYPE
doctypeSystemSub = do
    try (spaces1 >> caseInsensitiveString "SYSTEM")
    spaces1
    sysId <- dtdStringLiteral <?> ""
    if sysId == "about:legacy-compat"
        then return (DOCTYPE "html" (Just SYSTEM) Nothing (Just sysId))
        else fail $ "Expected system identifier \"about:legacy-compat\""

doctypePublicSub :: Stream s m Char => ParsecT s u m DOCTYPE
doctypePublicSub = do
    try (spaces1 >> caseInsensitiveString "PUBLIC")
    spaces1
    pubId <- dtdStringLiteral <?> ""
    sysId <- optionMaybe (try (spaces1 >> dtdStringLiteral)) <?> ""
    if (pubId, sysId) `elem` allowedPubIdSysIds
        then return $ DOCTYPE "html" (Just PUBLIC) (Just pubId) sysId
        else fail $ "Expected allowed values for public and system identifiers"

allowedPubIdSysIds :: [(String, Maybe String)]
allowedPubIdSysIds =
    [ ("-//W3C//DTD HTML 4.0//EN",
       (Just "http://www.w3.org/TR/REC-html40/strict.dtd"))
    , ("-//W3C//DTD HTML 4.0//EN",
       Nothing)
    , ("-//W3C//DTD HTML 4.01//EN",
       (Just "http://www.w3.org/TR/html4/strict.dtd"))
    , ("-//W3C//DTD HTML 4.01//EN",
       Nothing)
    , ("-//W3C//DTD XHTML 1.0 Strict//EN",
       (Just "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"))
    , ("-//W3C//DTD XHTML 1.1//EN",
       (Just "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd"))
    ]

dtdStringLiteral :: Stream s m Char => ParsecT s u m String
dtdStringLiteral = ((char '\'') >> manyTill anyChar (char '\''))
               <|> ((char '"' ) >> manyTill anyChar (char '"' ))


cdata :: Stream s m Char => ParsecT s u m String
cdata = string "<![CDATA[" >> (manyTill textChar $ try (string "]]>"))

caseInsensitiveString :: Stream s m Char => String -> ParsecT s u m String
caseInsensitiveString = sequence . map caseInsensitiveChar

caseInsensitiveChar :: Stream s m Char => Char -> ParsecT s u m Char
caseInsensitiveChar c = satisfy $ \c' -> toLower c == toLower c'

commentOrSpaces :: Stream s m Char => ParsecT s u m ()
commentOrSpaces = do
    many $ (try comment >> return ()) <|> try spaces1
    return ()

comment :: Stream s m Char => ParsecT s u m String
comment = do
    string "<!--"
    {- TODO: must reject three cases below:
     - 1. The first letter of the text is '-'.
     - 2. The text contains "--" in the middle.
     - 3. The last letter of the text is '-'.
     -}
    manyTill textChar $ try (string "-->")

parseTag :: Stream String Identity Char =>
    String -> Either ParseError Tag
parseTag = parse (spaces >> endTag) ""

startTag :: Stream s m Char => ParsecT s u m Tag
startTag = do
    char '<'
    name <- tagName
    attrs <- try $ option [] attributes
    spaces
    ((string "/>" >> return (StartTag name attrs True))
     <|> (char '>' >> return (StartTag name attrs False)))

endTag :: Stream s m Char => ParsecT s u m Tag
endTag = do
    string "</"
    name <- tagName
    spaces
    char '>'
    return (EndTag name)

tagName :: Stream s m Char => ParsecT s u m String
tagName = many1 alphaNum <?> "tag name"

attributes :: Stream s m Char => ParsecT s u m [Attribute]
attributes = do
    spaces1
    attrs <- sepBy1 (try attribute) spaces1
    return attrs

attribute :: Stream s m Char => ParsecT s u m Attribute
attribute = do
    name <- attributeName
    value <- optionMaybe $ try (spaces >> char '=' >> spaces >> attrValue
                                <?> "attribute value")
    return (Attribute name value)

attributeName :: Stream s m Char => ParsecT s u m String
attributeName = many1 attrNameChar

attrNameChar :: Stream s m Char => ParsecT s u m Char
attrNameChar = satisfy isAttrNameChar

attrValue :: Stream s m Char => ParsecT s u m String
attrValue = unquotedAttrValue
        <|> singleQuotedAttrValue
        <|> doubleQuotedAttrValue

unquotedAttrValue :: Stream s m Char => ParsecT s u m String
unquotedAttrValue = do
    strings <- many1 (attrValueChunk isUnquotedAttrValueChar)
    return $ concat strings

singleQuotedAttrValue :: Stream s m Char => ParsecT s u m String
singleQuotedAttrValue = do
    strings <- between (char '\'') (char '\'') $
               many1 (attrValueChunk isSingleQuotedAttrValueChar)
    return $ concat strings

doubleQuotedAttrValue :: Stream s m Char => ParsecT s u m String
doubleQuotedAttrValue = do
    strings <- between (char '"') (char '"') $
               many1 (attrValueChunk isDoubleQuotedAttrValueChar)
    return $ concat strings

attrValueChunk :: Stream s m Char => (Char -> Bool) -> ParsecT s u m String
attrValueChunk pred =
    ((try decimalCharRef <|> try hexadecimalCharRef) >>= checkRefChar)
    {- TODO: Enable to parse non-named-char-ref like "foo&bar" -}
    <|> namedCharRef
    <|> attrValueTextChunk pred

attrValueTextChunk :: Stream s m Char => (Char -> Bool) -> ParsecT s u m String
attrValueTextChunk pred = do
    c <- attrValueLeadChar pred
    cs <- many (attrValueTailChar pred)
    return (c:cs)

attrValueLeadChar :: Stream s m Char => (Char -> Bool) -> ParsecT s u m Char
attrValueLeadChar = satisfy

attrValueTailChar :: Stream s m Char => (Char -> Bool) -> ParsecT s u m Char
attrValueTailChar pred = satisfy $ \c -> (c /= '&' && pred c)

textChar :: Stream s m Char => ParsecT s u m Char
textChar = satisfy isTextChar

{-textChunk :: Stream s m Char => ParsecT s u m String
textChunk = do
    c <- textChar
    cs <- many textNoAmpChar
    return (c:cs)

textNoAmpChar :: Stream s m Char => ParsecT s u m Char
textNoAmpChar = satisfy $ \c -> isTextChar c && (c /= '&')-}

charRef :: Stream s m Char => ParsecT s u m String
charRef = ((try decimalCharRef <|> try hexadecimalCharRef) >>= checkRefChar)
        <|> namedCharRef

decimalCharRef :: Stream s m Char => ParsecT s u m Char
decimalCharRef = do
    string "&#"
    ds <- many1 digit
    char ';'
    return $ chr $ read ds

hexadecimalCharRef :: Stream s m Char => ParsecT s u m Char
hexadecimalCharRef = do
    string "&#"
    oneOf "xX"
    ds <- many1 hexDigit
    char ';'
    return $ chr $ hexToI ds

checkRefChar :: Stream s m Char => Char -> ParsecT s u m String
checkRefChar c =
    if (isAllowedRefChar c)
       then return [c]
       else unexpected "reference to a disallowed character"

namedCharRef :: Stream s m Char => ParsecT s u m String
namedCharRef = do
    char '&'
    name <- many1 alphaNum
    char ';'
    case (charRefNameToMaybeString name) of
        (Just value) -> return value
        Nothing -> unexpected "character reference name"

hexToI :: Num a => String -> a
hexToI ds = let ((n,_):_) = readHex ds
            in n

spaces1 :: Stream s m Char => ParsecT s u m ()
spaces1 = skipMany1 space

spaces :: Stream s m Char => ParsecT s u m ()
spaces = skipMany (space <?> "")

space :: Stream s m Char => ParsecT s u m Char
space = satisfy isSpaceChar


lookAheadSuccess :: Stream s m Char =>
                    ParsecT s u m a -> ParsecT s u m Bool
lookAheadSuccess p =
    (lookAhead p >> return True)
    <|> return False
    {-case r of
        (Left _) -> return False
        (Right _) -> return True-}

test1 :: Stream s m Char => ParsecT s u m (Maybe String, String)
test1 = do
    c <- optionMaybe (string "a")
    d <- string "b"
    return (c, d)
    {-case lookAhead (string "a") of
        (Right r) -> r
        (Left err) -> show err-}

test2 :: Stream s m Char => ParsecT s u m String
test2 =
    (lookAhead (spaces >> string "a") >> (spaces >> string "a"))
    <|> (spaces >> string "b")

test3 :: Stream s m Char => ParsecT s u m String
test3 = do
    r <- lookAheadSuccess (spaces >> string "a")
    if r
        then spaces >> string "a"
        else spaces >> string "b"

test4 :: Stream s m Char => ParsecT s u m String
test4 =
    try (spaces >> string "a=b" >> string " />")
    <|> (spaces >> string "a='b'" >> string "/>")

test5 :: Stream s m Char => ParsecT s u m [String]
test5 =
  do{ spaces1
    ; do{ a <- try (string "a=b")
        ; do{ b <- try test5
            ; return (a:b)
            }
          <|>
          do{ b <- try (spaces1 >> string "/>")
            ; return (a:[b])
            }
          <|>
          do{ b <- (spaces >> string ">")
            ; return (a:[b])
            }
      }
      <|>
      do{ a <- (string "a='b'")
        ; do{ b <- try test5
            ; return (a:b)
            }
          <|>
          do{ b <- try (spaces >> string "/>")
            ; return (a:[b])
            }
          <|>
          do{ b <- try (spaces >> string ">")
            ; return (a:[b])
            }
        }
    }
{-test5 =
  do{ a <- try (string "a=b")
    ; do{ b <- string " />"
        ; return (a ++ b)
        }
  }
  <|>
  do{ a <- string "a='b'"
    ; do{ b <- string "/>"
        ; return (a ++ b)
        }
    }-}
    

{-test5 =
    spaces >> (
        (string "a=b" >>= \a -> (
            string " />" >>= \b ->
            return a ++ b
          )
        )
        <|> (string "a='b'" >>= \a -> (
            string "/>" >>= \b ->
            return a ++ b
          )
        )
    )-}

{-test5 =
    letter >>= \c -> (
        test5 >>= \cs ->
        return (c:cs)
    )
    <|> return [c]-}

{-test5 = do {
    c <- letter;
    do {
        cs <- test5;
        return (c:cs)
    }
    <|> return [c]
  }  -}


{-test5 = do {
        spaces1;
        x <- string "a=b";
        do {
           xs <- test5;
           return x ++ xs;
          }    
        <|> return x
    }    

-}
